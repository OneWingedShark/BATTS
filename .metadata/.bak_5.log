!SESSION 2023-06-25 12:56:04.965 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.7
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\tiger\workspace\.metadata\.bak_4.log
Created Time: 2023-07-03 22:21:24.027

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:21:24.027
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:21:24.029
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:21:24.055
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:21:24.057
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:21:24.058
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:21:24.717
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
						(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:21:24.718
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:21:24.718
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:32:17.056
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:33:59.103
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:35:08.819
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:40:47.049
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:41:31.303
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:42:29.887
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-03 22:43:02.573
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:22.672
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index)))
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:43:22.702
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:43:22.703
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:23.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index)))
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:43:23.924
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:43:23.925
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:32.944
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index))).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:43:32.945
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:43:32.946
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:33.376
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index))).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:43:33.377
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:43:33.378
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:34.541
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index))).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:43:34.542
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:43:34.542
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:35.071
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index)).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:43:35.072
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:43:35.072
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:36.385
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)(Collections.reverse(input.subList(start_index, stop_index)).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:43:36.386
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:43:36.387
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:38.232
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)Collections.reverse(input.subList(start_index, stop_index)).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:43:38.234
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:43:38.234
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:38.261
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)Collections.reverse(input.subList(start_index, stop_index)).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:43:38.262
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:43:38.263
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:43:39.593
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			(ArrayList<Token>)Collections.reverse(input.subList(start_index, stop_index)).fo
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:43:39.594
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:43:39.595
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:38.303
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:45:38.304
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:45:38.304
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:38.647
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:38.649
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:38.649
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:39.489
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:45:39.490
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:45:39.491
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:39.896
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:39.897
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:39.898
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:45.427
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:45.428
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:45.429
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:46.668
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index).re;
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:45:46.669
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:45:46.669
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:46.695
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index).re;
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:46.696
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:46.697
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:47.379
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index).re;
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:47.380
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:47.381
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:48.304
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index).rev;
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:45:48.306
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:45:48.306
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:48.689
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index).rev;
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:48.691
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:48.691
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:49.840
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-04 10:45:49.841
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-04 10:45:49.841
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:50.183
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:50.186
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:50.186
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-04 10:45:50.820
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.collections.Pair;
import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			if( found_index+1 < Next_Quote-1 )
			  result.subList(found_index+1,Next_Quote).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case ch_Quote:		if (escaped_quote) {working.append('"');}
											escaped_quote = !escaped_quote;		break;
					case li_Character:  working.append("'''");
										escaped_quote = false;					break;
					case Text:
					case Whitespace:
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:
					case ss_Box:		working.append( element.Lexeme() );
										escaped_quote = false;					break;
					default:
						System.out.println( "ID " +element.ID().toString()+ " is unsupported." );
						break;
					}
				}
			});
			result.set(found_index, new Token(Token_ID.li_String, working.toString()) );
			working.delete(0,  working.length());
			for(int count = (Next_Quote-1) - (found_index); count >= 0; --count)
				result.remove(found_index+1);
		}
	
		return result;
	}
	
	/** Pass_8:
	 * Gather comments.
	 */
	public ArrayList<Token> Pass_8( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		ArrayList<Pair<Integer, Integer>> pair_list = new ArrayList<Pair<Integer, Integer>>();
		final StringBuilder working = new StringBuilder();
		Pair<Integer, Integer> pair;
		int start_index = 0;
		int stop_index;
		
		//Gather Comments
		while ( -1 < (start_index = search_index(input, start_index, Token_ID.ch_Dash)) ) 
		{ if( input.get(start_index+1).ID() == Token_ID.ch_Dash )
			{	
				stop_index = search_index(input, start_index, Token_ID.End_of_Line);
				pair = Pair.create(start_index, stop_index);
				pair_list.add( pair );
			}
		  else { stop_index = start_index+1; }
		}
		
		// Scan Data
		int last_index =  pair_list.size()-1;
		while ( last_index >= 0 )
		{   pair = pair_list.get(last_index);
			// Exclude the double-dash and end-of-line.
			start_index = pair.getLeft()+2;
			stop_index  = pair.getRight()-1;
			
			// Copy non-comment data.
			ArrayList<Token> NCD = input.subList(start_index, stop_index);
			
					(ArrayList<Token>) Collections.reverse() ;
			
			
			
			
		}
	
		return result;
	}

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		input = Pass_8(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-04 10:45:50.821
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-04 10:45:50.822
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:28:06.206
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:28:36.966
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:35:42.739
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:38:32.022
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:40:33.281
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:43:35.991
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:46:34.222
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:48:46.532
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:49:18.077
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:50:43.203
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:52:58.769
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 11:56:45.135
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:00:30.936
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:12:26.050
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:13:45.538
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.ui 4 0 2023-07-04 12:17:13.004
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 12:17:13.005
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 12:17:13.007
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 12:17:13.007
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:33:16.185
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:34:44.329
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:36:07.163
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:37:35.705
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.ui 4 0 2023-07-04 12:37:58.445
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 12:37:58.445
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 12:37:58.446
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 12:37:58.447
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:39:44.777
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:41:01.388
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:48:49.497
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:51:08.952
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:52:56.633
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:54:13.565
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:55:21.416
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 12:56:07.399
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:00:51.023
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:02:12.909
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:15:39.549
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:21:30.327
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:22:41.209
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:40:44.041
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:48:16.063
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:50:01.251
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:50:17.793
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:52:29.990
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:55:05.504
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:55:20.944
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 13:56:34.487
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:03:34.349
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:08:58.029
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:09:58.513
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:12:31.867
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:12:57.706
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:13:58.425
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:15:02.139
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:16:28.043
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:19:59.649
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:21:31.562
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:22:31.131
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:23:21.198
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:23:48.715
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:24:43.240
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 14:34:38.728
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 15:02:00.070
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 15:02:49.050
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 16:00:40.711
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 16:06:52.576
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 16:07:10.213
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.jdt.launching 4 4 2023-07-04 16:22:04.333
!MESSAGE Xbootclasspath option have been removed as not supported beyond Java 8.

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:40:27.603
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:40:27.607
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:40:27.609
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:40:27.609
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:40:31.769
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:40:31.769
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:40:31.770
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:40:31.771
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:43:16.199
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:43:16.199
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:43:16.201
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:43:16.201
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:43:17.945
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:43:17.945
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:43:17.946
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:43:17.946
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:43:21.362
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:43:21.363
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:43:21.364
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:43:21.365
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.builder.BuilderTargetMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more

!ENTRY org.eclipse.ui 4 0 2023-07-04 16:50:49.321
!MESSAGE Class load Failure: 'com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems'
!STACK 1
org.eclipse.core.runtime.CoreException: Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.throwException(RegistryStrategyOSGI.java:212)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:198)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at org.eclipse.ui.internal.util.Util.safeLoadExecutableExtension(Util.java:496)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.createContributionItem(DynamicMenuContributionItem.java:164)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.getContributionItem(DynamicMenuContributionItem.java:158)
	at org.eclipse.ui.internal.menus.DynamicMenuContributionItem.fill(DynamicMenuContributionItem.java:144)
	at org.eclipse.jface.action.MenuManager.doItemFill(MenuManager.java:729)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:806)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:673)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.scheduleManagerUpdate(MenuManagerRenderer.java:1227)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContents(MenuManagerRenderer.java:655)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.subscribeTopicChildAdded(MenuManagerRenderer.java:325)
	at jdk.internal.reflect.GeneratedMethodAccessor30.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.addUnique(NotifyingListImpl.java:356)
	at org.eclipse.emf.common.util.AbstractEList.add(AbstractEList.java:340)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributionRecord.mergeIntoModel(ContributionRecord.java:253)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processAddition(MenuManagerRenderer.java:551)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.generateContributions(MenuManagerRenderer.java:531)
	at org.eclipse.e4.ui.workbench.renderers.swt.MenuManagerRenderer.processContributions(MenuManagerRenderer.java:499)
	at org.eclipse.ui.internal.PopupMenuExtender.addMenuContributions(PopupMenuExtender.java:380)
	at org.eclipse.ui.internal.PopupMenuExtender.menuAboutToShow(PopupMenuExtender.java:355)
	at org.eclipse.jface.action.MenuManager.fireAboutToShow(MenuManager.java:338)
	at org.eclipse.jface.action.MenuManager.handleAboutToShow(MenuManager.java:468)
	at org.eclipse.jface.action.MenuManager$2.menuShown(MenuManager.java:495)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:259)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1090)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1071)
	at org.eclipse.swt.widgets.Control.WM_INITMENUPOPUP(Control.java:5140)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4772)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1478)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2306)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5040)
	at org.eclipse.swt.internal.win32.OS.TrackPopupMenu(Native Method)
	at org.eclipse.swt.widgets.Menu._setVisible(Menu.java:237)
	at org.eclipse.swt.widgets.Display.runPopups(Display.java:4113)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3654)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
!SUBENTRY 1 org.eclipse.equinox.registry 4 1 2023-07-04 16:50:49.321
!MESSAGE Plug-in com.adacore.gnatbench.ui was unable to load class com.adacore.gnatbench.ui.internal.commands.AdaMenuContributionItems.
!STACK 0
java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.ui (520).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.loadClass(EquinoxBundle.java:622)
	at org.eclipse.core.internal.registry.osgi.RegistryStrategyOSGI.createExecutableExtension(RegistryStrategyOSGI.java:196)
	at org.eclipse.core.internal.registry.ExtensionRegistry.createExecutableExtension(ExtensionRegistry.java:920)
	at org.eclipse.core.internal.registry.ConfigurationElement.createExecutableExtension(ConfigurationElement.java:246)
	at org.eclipse.core.internal.registry.ConfigurationElementHandle.createExecutableExtension(ConfigurationElementHandle.java:63)
	at com.adacore.gnatbench.startup.StartupPerspectiveChangeListener$1.run(StartupPerspectiveChangeListener.java:116)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.osgi.framework.BundleException: Error loading bundle activator. com.adacore.gnatbench.ui_2.7.0.20121108 [520]
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:761)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 15 more
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	... 21 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/core/internal/GNATbenchCorePlugin
	at com.adacore.gnatbench.ui.internal.GNATbenchUIPlugin.<init>(GNATbenchUIPlugin.java:123)
	... 28 more
Caused by: java.lang.ClassNotFoundException: An error occurred while automatically activating bundle com.adacore.gnatbench.core (514).
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:126)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:570)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:335)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:397)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:496)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 29 more
Caused by: org.osgi.framework.BundleException: Error starting module. osgi.identity; type="osgi.bundle"; version:Version="2.7.0.20121108"; osgi.identity="com.adacore.gnatbench.core"; singleton:="true" [id=514]
	at org.eclipse.osgi.container.Module.doStart(Module.java:614)
	at org.eclipse.osgi.container.Module.start(Module.java:468)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:513)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	... 37 more
Caused by: java.lang.NoClassDefFoundError: com/adacore/gnatbench/library/Toolchains/Toolchain_Manager_Record
	at java.base/java.lang.Class.getDeclaredConstructors0(Native Method)
	at java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3373)
	at java.base/java.lang.Class.getConstructor0(Class.java:3578)
	at java.base/java.lang.Class.getConstructor(Class.java:2271)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.loadBundleActivator(BundleContextImpl.java:801)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:753)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1032)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:371)
	at org.eclipse.osgi.container.Module.doStart(Module.java:605)
	... 40 more
Caused by: java.lang.ClassNotFoundException: com.adacore.gnatbench.library.Toolchains.Toolchain_Manager_Record cannot be found by com.adacore.gnatbench.core_2.7.0.20121108
	at org.eclipse.osgi.internal.loader.BundleLoader.generateException(BundleLoader.java:541)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass0(BundleLoader.java:536)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:416)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:168)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)
	... 49 more
