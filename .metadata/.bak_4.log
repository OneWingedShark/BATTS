!SESSION 2023-06-25 12:56:04.965 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.7
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\tiger\workspace\.metadata\.bak_3.log
Created Time: 2023-07-03 22:15:26.072

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:15:26.073
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:		(Magic_Values.Seperators_1 +  6),
				    ch_Close_Paren		(Magic_Values.Seperators_1 +  7),
				    ch_Plus				(Magic_Values.Seperators_1 +  8),
				    ch_Comma			(Magic_Values.Seperators_1 +  9),
				    ch_Dash				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:15:26.074
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:15:26.075
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:15:26.102
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:		(Magic_Values.Seperators_1 +  6),
				    ch_Close_Paren		(Magic_Values.Seperators_1 +  7),
				    ch_Plus				(Magic_Values.Seperators_1 +  8),
				    ch_Comma			(Magic_Values.Seperators_1 +  9),
				    ch_Dash				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:15:26.104
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:15:26.104
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:15:36.361
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:		(Magic_Values.Seperators_1 +  7),
				    ch_Plus				(Magic_Values.Seperators_1 +  8),
				    ch_Comma			(Magic_Values.Seperators_1 +  9),
				    ch_Dash				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:15:36.362
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:15:36.362
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:15:59.064
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:				(Magic_Values.Seperators_1 +  8),
				    ch_Comma			(Magic_Values.Seperators_1 +  9),
				    ch_Dash				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:15:59.065
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:15:59.066
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:15:59.084
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:				(Magic_Values.Seperators_1 +  8),
				    ch_Comma			(Magic_Values.Seperators_1 +  9),
				    ch_Dash				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:15:59.086
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:15:59.087
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:15:59.831
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:				(Magic_Values.Seperators_1 +  8),
				    ch_Comma			(Magic_Values.Seperators_1 +  9),
				    ch_Dash				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:15:59.832
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:15:59.832
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:16:15.013
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:16:15.014
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:16:15.015
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:16:15.037
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:				(Magic_Values.Seperators_1 + 10),
				    ch_Slash			(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:16:15.039
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:16:15.040
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:16:26.973
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
						(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:16:26.974
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:16:26.974
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:16:27.414
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
						(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:16:27.416
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:16:27.417
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:16:29.014
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					(Magic_Values.Seperators_1 + 11),
				    ch_Colon			(Magic_Values.Seperators_1 + 12),
				    ch_Semicolon		(Magic_Values.Seperators_1 + 13),
				    ch_Less_Than		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:16:29.015
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:16:29.015
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:08.857
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:08.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:08.859
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:08.884
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:		(Magic_Values.Seperators_1 + 14),
				    ch_Greater_Than		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:08.886
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:08.887
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:17.091
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:17.092
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:17.093
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:17.117
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:17.119
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:17.120
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:18.261
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:		(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:18.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:18.264
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:19.052
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
						(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:19.054
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:19.055
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:19.496
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
						(Magic_Values.Seperators_1 + 15),
				    ch_Equal			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:19.498
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:19.498
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:26.083
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:26.084
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:26.085
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:26.106
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:			(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:26.107
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:26.108
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:27.265
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
						(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:27.266
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:27.266
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:27.727
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
						(Magic_Values.Seperators_1 + 16),
				    ch_Quote			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:27.729
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:27.729
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:35.687
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Quote:			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:35.688
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:35.688
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:36.133
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Quote:			(Magic_Values.Seperators_1 + 17),
				    ch_Period			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:36.134
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:36.134
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:45.840
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Quote:
					case ch_Period:			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:17:45.841
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:17:45.842
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:17:45.864
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Quote:
					case ch_Period:			(Magic_Values.Seperators_1 + 18),
				    ch_Vertical_Line	(Magic_Values.Seperators_1 + 19),

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:17:45.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:17:45.866
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:19:48.601
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:			(Magic_Values.Seperators_2 +  0),
				    ss_Arrow			(Magic_Values.Seperators_2 +  1),
				    ss_Open_Label		(Magic_Values.Seperators_2 +  2),
				    ss_Close_Label		(Magic_Values.Seperators_2 +  3),
				    ss_Dillipsis		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:19:48.603
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:19:48.603
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:19:50.205
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:			(Magic_Values.Seperators_2 +  0),
				    ss_Arrow			(Magic_Values.Seperators_2 +  1),
				    ss_Open_Label		(Magic_Values.Seperators_2 +  2),
				    ss_Close_Label		(Magic_Values.Seperators_2 +  3),
				    ss_Dillipsis		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:19:50.207
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:19:50.208
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:19:58.150
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:			(Magic_Values.Seperators_2 +  1),
				    ss_Open_Label		(Magic_Values.Seperators_2 +  2),
				    ss_Close_Label		(Magic_Values.Seperators_2 +  3),
				    ss_Dillipsis		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:19:58.152
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:19:58.152
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:20:04.840
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:		(Magic_Values.Seperators_2 +  2),
				    ss_Close_Label		(Magic_Values.Seperators_2 +  3),
				    ss_Dillipsis		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:20:04.842
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:20:04.843
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:20:06.023
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:		(Magic_Values.Seperators_2 +  2),
				    ss_Close_Label		(Magic_Values.Seperators_2 +  3),
				    ss_Dillipsis		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:20:06.024
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:20:06.025
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:20:15.703
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:		(Magic_Values.Seperators_2 +  3),
				    ss_Dillipsis		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:20:15.705
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:20:15.705
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:20:24.525
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:20:24.526
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:20:24.527
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:20:24.547
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:		(Magic_Values.Seperators_2 +  4),  //> A two/dot ellipsis.
				    ss_Exponent			(Magic_Values.Seperators_2 +  5),
				    ss_Not_Equal		(Magic_Values.Seperators_2 +  6),
				    ss_Greater_Equal	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-07-03 22:20:24.549
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-07-03 22:20:24.550
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:20:52.149
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:	(Magic_Values.Seperators_2 +  7),
				    ss_Less_Equal		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-07-03 22:20:52.150
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-07-03 22:20:52.151
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-03 22:21:24.024
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package package_Ada_Language.lexington;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Spliterators;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.UnaryOperator;

import org.graalvm.shadowed.org.jcodings.specific.UTF32LEEncoding;
import org.graalvm.shadowed.org.jcodings.unicode.UnicodeEncoding;

import com.oracle.truffle.api.strings.TruffleString;
import com.oracle.truffle.api.strings.TruffleString.CodePointSet;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

public class Lexer
{
	
	private int is_in(String text, String[] items)
	{int index = Integer.MAX_VALUE;
		for (int i = 0; i < items.length; i++) 
		{ int tmp = text.indexOf(items[i]);
			index = Integer.min(tmp == -1 ? Integer.MAX_VALUE : tmp, index);
		}			

		return index == Integer.MAX_VALUE ? -1 : index;
	} //*/

	/*
	//private ArrayList<Token> result = new ArrayList<Token>();
	private ArrayList<Token> split_text(Token t, String trigger, Token_ID result)
	{	ArrayList<Token> working = new ArrayList<Token>();
		final String text = t.Lexeme();
		int start = 0;
		
			for (int index = text.indexOf(trigger); start != 0; index++) //index < 0; index = text.indexOf(trigger, start))
			{
				String prefix = text.substring(start, index-1);
				if (prefix.length() > 0) { working.add(  new Token(t.ID(), prefix)  ); }
				start = index = trigger.length() - 1;
				working.add(  new Token(result, text.substring(index, start)) );
			}
		
		String postfix = text.substring(start);
		if (postfix.length() > 0)  { working.add(  new Token(t.ID(), postfix)  ); }

		return working;
	}//*/

	
	
	public String Read_File( FileInputStream fs )
	{	String result = "";
		UnicodeReader ur = null;
			//InputStreamReader isr = new InputStreamReader(fs, "UTF-8"); //"UTF-32LE");
		try
		{try 
			{ur = new UnicodeReader(fs, "UTF-8");
				result = ur.toString();
			}
			finally
			{
				if (ur != null) ur.close();
				fs.close();
			}	
		} catch (IOException e) { e.printStackTrace(); }
		
		return result;
	}
	
	public ArrayList<Token> Make_Text( String input )
	{	return new ArrayList<Token>(Collections.singletonList(new Token(Token_ID.Text, input)));	}
	
	public ArrayList<Token> Pass_1( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		input.forEach(
				new Consumer<Token>() {
					final char nbsp  = (char) 160;
					final char space = ' ';
					final char tilde = '~';
					final char wc256 = (char) 256;
					final char wclst = Character.MAX_VALUE;
					
					private boolean in_range(char c, char low, char high)
					{ return (low <= c && c <= high); }
					private boolean Non_Whitespace( char c )
					{
						return  (in_range(c, space, tilde) || in_range(c, wc256, wclst))
								&& (c != space) && (c != nbsp);
					}
					
					
					@Override
					public void accept(Token item)
					{
						if ( item.ID() == Token_ID.Text)
						{	final String text = item.Lexeme();
							StringBuilder sb = new StringBuilder();

							/* we iterate through the text of the token, collecting non-whitespace characters
							   into the string-builder, when we hit a whitespace character we have to emit
							   that into a text-token, then emit the whitespace-token, emptying the string-
							   builder collection.
							 */
							for (char c : text.toCharArray()) {
								if (Non_Whitespace(c)) { sb.append(c); }
								else {
									if (sb.length() > 0)
									{ result.add( new Token(Token_ID.Text, sb.toString()) ); 
									  sb.delete(0, sb.length());
									}
									sb.append(c);
									result.add( new Token(Token_ID.Whitespace, sb.toString() ) );
									sb.delete(0,1);
								}
							} // for
							
							if (sb.length() > 0) { result.add( new Token(Token_ID.Text, sb.toString()) ); }
						} // if
				} //accept
				} // consumer class
			);
		//ArrayList<String> parts = new ArrayList<>(Arrays.asList(textField.getText().split(",")));
		//Spliterators.
		//ArrayList<Token> JJ = new ArrayList<>( (List)input.spliterator(  ) );
	
		return result;
	}

	public final static char CR  = (char) 0x0D;
	public final static char LF  = (char) 0x0A; 
	
	public ArrayList<Token> Pass_2( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  ArrayList<Token>  working		= new ArrayList<Token>();
		/* 
		 
		 */
	
		// Take care of RFC822-style end-of-lines. (CRLF)
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
			if (item.ID() == Token_ID.Whitespace && item.Lexeme() == ""+CR)
			{	Token next = input.get(i+1);
				if (next.ID() == Token_ID.Whitespace && next.Lexeme() == ""+LF)
				{
					working.add( new Token(Token_ID.End_of_Line, "") );
					++i;
				}
			} else { working.add(item); }
		}
		
		working.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item){
				if (item.ID() != Token_ID.Whitespace)
				{result.add(item);}
				else
					if ((item.Lexeme() == ""+CR) || (item.Lexeme() == ""+LF))
					{ result.add( new Token(Token_ID.End_of_Line, "") ); }
					else result.add(item);
			}
		} );
		
	
		return result;
	}
	
	static boolean is_comment(Token item)
	{	final String text = item.Lexeme(); 
	    final boolean possible = item.ID() == Token_ID.Text && text.length() >= 2; 
		return possible ? (text.charAt(0) == '-') && (text.charAt(1) == '-') : false;
	}
	
	//handles comments starting text-token.
	public ArrayList<Token> Pass_3( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		final ArrayList<Token>  working		= new ArrayList<Token>();
	
		boolean marked = false;
		for (int i = 0; i < input.size(); i++) 
		{
			Token item = input.get(i);
			if (is_comment(item) && !marked)
	 		{ marked = true; 
	 		  working.add( new Token(Token_ID.Comment, item.Lexeme().substring(2) ) );
	 		} else if ( marked && (item.ID() == Token_ID.End_of_Line || input.size()-1 == i) ) 
	 		{ marked = false; working.add(item); }
	 		else working.add(item);
		}
		
		working.add( new Token(Token_ID.Nil,"") );
		working.forEach( new Consumer<Token>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{ /*throw new Exception("New comment started before old comment was closed.");*/ }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
	
		return result;
	} /* Pass_3 */
	
	
	public ArrayList<Token> Pass_4( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
			  //ArrayList<Token>  working		= new ArrayList<Token>();

		final Map<Character, Token_ID> delimiter = new HashMap<Character, Token_ID>();
		{
			delimiter.put( '&', Token_ID.ch_Ampersand );
			delimiter.put( '*', Token_ID.ch_Astrisk );
			delimiter.put( '\'', Token_ID.ch_Apostrophy );
			delimiter.put( '(', Token_ID.ch_Open_Paren );
			delimiter.put( ')', Token_ID.ch_Close_Paren );
			delimiter.put( '+', Token_ID.ch_Plus );
			delimiter.put( ',', Token_ID.ch_Comma );
			delimiter.put( '-', Token_ID.ch_Dash );
			delimiter.put( '/', Token_ID.ch_Slash );
			delimiter.put( ':', Token_ID.ch_Colon );
			delimiter.put( ';', Token_ID.ch_Semicolon );
			delimiter.put( '<', Token_ID.ch_Less_Than );
			delimiter.put( '>', Token_ID.ch_Greater_Than );
			delimiter.put( '=', Token_ID.ch_Equal );
			delimiter.put( '"', Token_ID.ch_Quote );
			delimiter.put( '.', Token_ID.ch_Period );
			delimiter.put( '|', Token_ID.ch_Vertical_Line );
		}; 


		
		input.forEach( new Consumer<Token>() {
			@Override
			public void accept(Token item) {
				if (item.ID() != Token_ID.Text) 
				{  result.add(item);  }
				else 
				{ //final ArrayList<Token>  working = new ArrayList<Token>(); //Collections.singletonList(item));
				  final StringBuilder buffer = new StringBuilder();
				  final String lex = item.Lexeme();
				  for (int i = 0; i < lex.length(); i++)
				  {   final char ch = lex.charAt(i);
					  if ( delimiter.containsKey( ch ) )
					  {
						  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
						  result.add( new Token( delimiter.get(ch), ""+lex.charAt(i) ) );
					  }
					  else
					  { buffer.append(ch); }
				  }
				  if (buffer.length() > 0) { result.add( new Token(Token_ID.Text, buffer.toString()) ); buffer.delete(0, buffer.length()); }
/*
				  delimiter.forEach( new BiConsumer<Character, Token_ID>() {
					@Override
					public void accept(Character k, Token_ID value) {
						working.forEach( element -> if ( item.Lexeme().inde ) 
								);
						result.add( new Token( delimiter.get('l'), "" ) );
					 }
				   } );
*/
				} //else
			}
		} );
		
		
		
		/*
		delimiter.forEach( new Consumer<>(){			
			
			boolean marked = false;
			StringBuilder working = new StringBuilder();
			@Override
			public void accept(Token item)
		 	{	
				     if (!marked && item.ID() != Token_ID.Comment)
		 		{ result.add(item); }
		 		else if (!marked && item.ID() == Token_ID.Comment)
		 		{ marked = true;  working.append(item.Lexeme()); }
		 		else if ( marked && item.ID() == Token_ID.Comment)
		 		{  }
		 		else if ( marked && item.ID() == Token_ID.End_of_Line)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else if ( marked && item.ID() == Token_ID.Nil)
		 		{ marked = false; result.add( new Token(Token_ID.Comment, working.toString()) ); working.delete(0, working.length());}
		 		else
		 		{ working.append( item.Lexeme() ); }
		 }}
		);
		//*/
		
		return result;
	}
	
	/** PASS_5:
	 *  Produce the two-character delimiters.
	 */
	public ArrayList<Token> Pass_5( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
	
		for (int i = 0; i < input.size()-1; i++) 
		{	Token item = input.get(i);
		    Token next = input.get(i+1);
			switch (item.ID()) {
				case ch_Less_Than: 
					switch (next.ID()) {
						case ch_Less_Than:
							result.add( new Token(Token_ID.ss_Open_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Less_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Box, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Greater_Than:
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Close_Label, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Greater_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Slash: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Not_Equal, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Colon: 
					switch (next.ID()) {
						case ch_Equal:
							result.add( new Token(Token_ID.ss_Assign, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Astrisk: 
					switch (next.ID()) {
						case ch_Astrisk:
							result.add( new Token(Token_ID.ss_Exponent, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Equal: 
					switch (next.ID()) {
						case ch_Greater_Than:
							result.add( new Token(Token_ID.ss_Arrow, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
				case ch_Period: 
					switch (next.ID()) {
						case ch_Period:
							result.add( new Token(Token_ID.ss_Dillipsis, item.Lexeme()+next.Lexeme()) ); input.remove(i+1);	break;
						default:
							result.add(item);
						break;
					}
				break;
			default:
				result.add(item);
				break;
			}
		}
	
		return result;
	}	
	
	private int search_index( ArrayList<Token> input, int from, Token_ID id )
	{ int result = -1;
		
		for (int i = from; i < input.size(); i++)
		{	Token item = input.get(i);
			if (item.ID() == id) { result = i; break;}
		}
		
		return result;
	}
	
	private boolean is_QorA( Token item )
	{	return (item.ID() == Token_ID.ch_Apostrophy || item.ID() == Token_ID.ch_Quote);		}
	
	/** PASS_6
	 * Produces li_Character ONLY for apostrophe and quote.
	 */
	public ArrayList<Token> Pass_6( ArrayList<Token> input )
	{	ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Apostrophy)) >= 0 )
		{
				final boolean in_range = found_index <= result.size()-1;
				if (in_range)
				{
					final Token second = result.get(found_index+1); 
					final Token third  = result.get(found_index+2);
					if (is_QorA(second) && (third.ID() == Token_ID.ch_Apostrophy) )
					{ 	final char lit_chr = (second.ID() == Token_ID.ch_Apostrophy) ? '\'': '"';
						final Token literal = new Token(Token_ID.li_Character, ""+lit_chr);
						result.set( found_index, literal );
					  result.remove(found_index+1);
					  result.remove(found_index+1);
					}
				}
				start_index = found_index + 1;
		} // while
		
		return result;
	}
	

	/** PASS_7:
	 * Produce li_String tokens.
	 */
	public ArrayList<Token> Pass_7( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= input;
		int start_index = 0;
		int found_index;
		boolean closing = false;
	
		while ( (found_index = search_index(result, start_index, Token_ID.ch_Quote)) >= 0 )
		{	int Next_Quote = found_index+1;
			/* if (next_quote < 0) {throw new Exception("Unterminated String literal.");} */
			while ( (Next_Quote = search_index(result, Next_Quote, Token_ID.ch_Quote)) >= 0 )
			{
				closing = result.get(Next_Quote+1).ID() != Token_ID.ch_Quote;
				if (closing){ break; }
				else {Next_Quote = Next_Quote+2;}
			}
			
			final StringBuilder working = new StringBuilder();
			result.subList(found_index+1,Next_Quote-1).forEach(new Consumer<Token>() {
				boolean escaped_quote = false;
				@Override
				public void accept(Token element) {
					switch (element.ID()) 
					{
					case li_Character:	working.append( "'" );						break;
					case ch_Quote:		escaped_quote = !escaped_quote;
										if (escaped_quote) working.append('"');		break;
					case ch_Ampersand:
					case ch_Astrisk:
					case ch_Apostrophy:
					case ch_Open_Paren:
					case ch_Close_Paren:
					case ch_Plus:
					case ch_Comma:
					case ch_Dash:
					case ch_Slash:
					case ch_Colon:
					case ch_Semicolon:
					case ch_Less_Than:
					case ch_Greater_Than:
					case ch_Equal:
					case ch_Period:
					case ch_Vertical_Line:
					case ss_Assign:
					case ss_Arrow:
					case ss_Open_Label:
					case ss_Close_Label:
					case ss_Dillipsis:
					case ss_Exponent:
					case ss_Not_Equal:
					case ss_Greater_Equal:
					case ss_Less_Equal:		(Magic_Values.Seperators_2 +  8),
				    ss_Box				(Magic_Values.Seperators_2 +  9),
										working.append( element.Lexeme() );			break;
					case 

					default:
						break;
					}
				}
			});
			
		
		}
	
		return result;
	}
	

	
	public ArrayList<Token> Pass_X( ArrayList<Token> input )
	{	final ArrayList<Token>  result		= new ArrayList<Token>();
		
		return result;
	}

/***************************************
 *  Anonymous Consumer class Template  * 
 *                                     *
 ***************************************/
/*	
		input.forEach(
				new Consumer<Token>() {
					@Override
					public void accept(Token t)
					{
						working.add( new Token(Token_ID.kw_Parallel, "Steve!") );
						if (t.ID() == Token_ID.Text)
						{   //working = new ArrayList<Token>();
							split_text(t, " ",  Token_ID.Whitespace).forEach(null)
		;
						  working.addAll( split_text(t, "\t", Token_ID.Whitespace) );
						  // \u00A0, \u2007 and, \u202F
						  working.addAll( split_text(t, "\u00A0F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u2007F", Token_ID.Whitespace) );
						  working.addAll( split_text(t, "\u202F",  Token_ID.Whitespace) );
						}
				
					}
				}
			);
	
//*/
	
	public ArrayList<Token> Do_Passes( ArrayList<Token> input )
	{
		input = Pass_1(input);
		input = Pass_2(input);
		input = Pass_3(input);
		input = Pass_4(input);
		input = Pass_5(input);
		input = Pass_6(input);
		input = Pass_7(input);
		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3225)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3112)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2541)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2059)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)
